IOC - inversion of control container- control is passed to springboot via us to create object instanaces
    - container contains collection of classes and objects which are used in springboot application context.
    - there is no manual creation of objects.
    - objects in IOC container are called beans

 @springbootapplication 

- main file 
-used to configure and bootstrap a Spring Boot application
-The @SpringBootApplication annotation is a meta-annotation that combines three other annotations:
@EnableAutoConfiguration
@ComponentScan
@Configuration

@EnableAutoConfiguration:

This enables Spring Boot's auto-configuration feature.
It allows Spring Boot to automatically configure beans based on the dependencies you have included in your pom.xml or build.gradle.
For example, if spring-boot-starter-web is on the classpath, Spring Boot will automatically configure things like an embedded Tomcat server, DispatcherServlet, and other web-related beans.

REST API: RESPRESENTATION STATE TRANSFER 
------------------------------------------
- used as enabling communication between server and client end through HTTP end points.

Spring Data JPA 
--------------------

is a part of the larger Spring Data ecosystem that makes it easier to interact with relational databases using the Java Persistence API (JPA). 
It *abstracts away much of the boilerplate code required to interact with databases, allowing you to focus more on writing business logic rather than database operations.* 
It is particularly useful when working with data in a database like MySQL, MariaDB, PostgreSQL, etc.

=>Java Persistence API (JPA):
-------------------------------
JPA is a standard specification in Java for object-relational mapping (ORM). *It allows developers to map Java objects to database tables and vice versa.*

It defines a set of interfaces for working with databases using entities (Java objects) and annotations to map these entities to tables.

Examples of JPA providers include Hibernate, EclipseLink, and OpenJPA. Spring Data JPA typically uses Hibernate under the hood.

=>Spring Data JPA:
--------------------
It is built on top of JPA and Hibernate, providing an additional layer of abstraction that simplifies CRUD (Create, Read, Update, Delete) operations.

It eliminates the need to write complex queries by providing a repository pattern, which makes interacting with the database as simple as calling methods.

Using Spring Data JPA, you can create repositories (interfaces) that automatically provide database operations like findAll, save, delete, and custom queries using method naming conventions.

=>COMPONENTS OF SD JPA:

@Entity Annotation:
--------------------

This annotation marks a class as a JPA entity, which means it will map to a table in the database.

Example:

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
}
In this example, User is an entity class mapped to a user table in the database.

@Repository Interface:
-----------------------

Spring Data JPA allows you to define repository interfaces that extend the JpaRepository interface.

*JpaRepository comes with built-in CRUD operations like save(), findAll(), findById(), delete(), etc.*

Example:

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByName(String name);
}
In this example, UserRepository extends JpaRepository and inherits several database operations for User entities. 
It also defines a custom query method findByName that Spring Data JPA will automatically translate into a SQL query.

@Service Annotation:
---------------------
This annotation is used to mark a class as a service provider, where you can define the business logic.

Example:

@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public User createUser(User user) {
        return userRepository.save(user);
    }
}

Query Methods:
---------------

Spring Data JPA supports query methods that are automatically generated based on method names.

Example:

List<User> findByEmail(String email);
List<User> findByNameAndAge(String name, int age);
 
These methods will automatically generate SQL queries like SELECT * FROM user WHERE email = ? and SELECT * FROM user WHERE name = ? AND age = ?.

=>Benefits of Using Spring Data JPA
-------------------------------------

Reduced Boilerplate Code: It eliminates the need to write most of the code for database access and handling.
Easy to Use: The repository interfaces make it simple to perform CRUD operations with minimal effort.
Integration with Spring Boot: It integrates well with Spring Boot, making it easy to set up and use in projects.
Support for JPQL and Native Queries: You can write JPQL (Java Persistence Query Language) or native SQL queries when needed, allowing for flexibility.

=>How Spring Data JPA Works
-----------------------------

When you define an entity class (like User) with annotations like @Entity, Spring Data JPA maps it to a corresponding table.

The repository interface (like UserRepository) provides methods to interact with the database without writing SQL directly.

When you call methods on the repository (e.g., userRepository.findAll()), Spring Data JPA generates SQL queries behind the scenes.
____________________________________________________________________________

It uses a JPA provider like Hibernate to execute the queries and map the results back to Java objects.

SPRIMG
